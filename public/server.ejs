<head>
    <meta charset="gbk">
    <title>Camera</title>
    <style>
        #user-list>li {
            font-size: 24px;
        }
    </style>
    <script type="javascript" src="/root/webrtc/fix-webm-duration.js"></script>
</head>

<body>
    <h1 id="user-id">
        <%= msg.user.stu_no %>
    </h1>
    <button type="button" name="get" onclick="GetState()">Get All Students' State</button>
    <table border="1">
        <tr>
            <th>stu_no</th>
            <th>stu_state</th>
        </tr>
        <% for(var i=0; i < msg.stu.length; i++){ %>
            <tr id="stu<%= i %>">
                <td>
                    <%= msg.stu[i].stu_no %>
                </td>
                <td id="stu<%= i %>_state">not init</td>
            </tr>
            <% } %>
    </table>
    <br><br><br>
    <select id="stuselect" onChange="displaystu()">
        <option selected="selected">change student <b class="caret"></b></option>
        <% for(var i=0; i < msg.stu.length; i++){ %>
            <option>
                <%= msg.stu[i].stu_no %>
            </option>
            <% } %>
    </select>

    <div id="videos"></div>

    <script src="//cdn.bootcdn.net/ajax/libs/socket.io/3.0.4/socket.io.js"></script>
    <script src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js"></script>
    <script type="javascript" src="/root/webrtc/fix-webm-duration.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.9.5/dist/ffmpeg.min.js"></script>
    <script src="https://www.webrtc-experiment.com/EBML.js"></script>
    <script>
        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({ log: true });
        //PeerConnection
        var pc = [];
        var localStream = null;
        var num = 0;
        var mediaRecorder = [];
        var recordChunks = [];
        var clientnum1 = [], clientnum2 = [];
        var recordMediaType = 'video/webm;codecs=vp8,opus';
        var startTime = [];
        var stutable = [];
        var restutable = [];
        var stuonline = [];
        function displaystu() {
            var sel = document.getElementById('stuselect')
            var index = sel.selectedIndex
            var no = sel.options[index].text
            console.log('aaaaaaaa')

            for (let i = 0; i < num; ++i)
                document.getElementById(i + '-div').style.display = 'none'
            document.getElementById(clientnum1[restutable[no]] + '-div').style.display = 'block'
            document.getElementById(clientnum2[restutable[no]] + '-div').style.display = 'block'
        }

        function GetState() {
            var stu = `<%= msg.stu %>`
            console.log(stu.length)
            console.log(stu[0])
            console.log(stu[1])
            for(let i = 0;i<stu.length;i++){
                if(stuonline[stu[i].stu_no]==true){
                    document.getElementById('stu'+i+'_state').innerHTML='online'
                }
                else{
                    document.getElementById('stu'+i+'_state').innerHTML='not online'
                }
            }
        }

        window.onload = function () {
            //var ysFixWebmDuration = ysFixWebmDuration;
            function getSeekableBlob(inputBlob, num, kind, parterName) {
                // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml
                if (typeof EBML === 'undefined') {
                    throw new Error('Please link: https://www.webrtc-experiment.com/EBML.js');
                }

                var reader = new EBML.Reader();
                var decoder = new EBML.Decoder();
                var tools = EBML.tools;

                var fileReader = new FileReader();
                fileReader.onload = function (e) {
                    var ebmlElms = decoder.decode(this.result);
                    ebmlElms.forEach(function (element) {
                        reader.read(element);
                    });
                    reader.stop();
                    var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);
                    var body = this.result.slice(reader.metadataSize);
                    var newBlob = new Blob([refinedMetadataBuf, body], {
                        type: 'video/webm'
                    });

                    console.log(newBlob);
                    var formData = new FormData();
                    formData.append("content", newBlob);
                    formData.append("stu_no", stutable[parterName].stu_no)
                    formData.append("stu_name", stutable[parterName].stu_name)
                    formData.append("kind", kind)

                    console.log(formData.get("content"))

                    let xhr = new XMLHttpRequest
                    xhr.overrideMimeType("video/webm;charset=gb2312")
                    xhr.open('post', '/saveVideo')
                    xhr.send(formData)
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200) {
                                const data = JSON.parse(xhr.responseText)
                                console.log('³É¹¦£º', data)
                            } else {
                                console.log('Ê§°Ü')
                            }
                        }
                    }
                };
                fileReader.readAsArrayBuffer(inputBlob);
            }

            function getUserMedia(constrains, success, error) {
                if (navigator.mediaDevices.getUserMedia) {
                    promise = navigator.mediaDevices.getUserMedia(constrains).then(success).catch(error);
                } else if (navigator.webkitGetUserMedia) {
                    promise = navigator.webkitGetUserMedia(constrains).then(success).catch(error);
                } else if (navigator.mozGetUserMedia) {
                    promise = navagator.mozGetUserMedia(constrains).then(success).catch(error);
                } else if (navigator.getUserMedia) {
                    promise = navigator.getUserMedia(constrains).then(success).catch(error);
                }
            }

            function canGetUserMediaUse() {
                return !!(navigator.mediaDevices.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
            }

            const localVideoElm = document.getElementById("video-local");

            const iceServer = {
                iceServers: [{ urls: ["stun:ss-turn1.xirsys.com"] }, { username: "CEqIDkX5f51sbm7-pXxJVXePoMk_WB7w2J5eu0Bd00YpiONHlLHrwSb7hRMDDrqGAAAAAF_OT9V0dWR1d2Vi", credential: "446118be-38a4-11eb-9ece-0242ac140004", urls: ["turn:ss-turn1.xirsys.com:80?transport=udp", "turn:ss-turn1.xirsys.com:3478?transport=udp"] }]
            };


            function StartRecord(stream, num) {
                let option = { mimeType: recordMediaType };
                mediaRecorder[num] = new MediaRecorder(stream, option);
                console.log(num + 'recorder statred');
                recordChunks[num] = [];
                mediaRecorder[num].start(80);
                startTime[num] = new Date().getTime();
                console.log(mediaRecorder[num].state)

                mediaRecorder[num].ondataavailable = function (e) {
                    console.log("data available", e.data);
                    recordChunks[num].push(e.data);
                }
            }

            function StopRecord(num, kind, parterName) {
                if (!mediaRecorder[num]) {
                    console.log('stream ' + num + ' is not created!');
                    return;
                }
                mediaRecorder[num].stop();
                var duration = new Date().getTime() - startTime[num];
                console.log('recorder ' + num + ' stopped');

                const blob = new Blob(recordChunks[num], { type: recordMediaType });
                getSeekableBlob(blob, num, kind, parterName);
                //console.log(blob);
                //console.log(recorderFile);
            }

            function StartCall(parterName, createOffer) {

                pc[parterName] = new RTCPeerConnection(iceServer);

                pc[parterName].onicecandidate = ({ candidate }) => {
                    socket.emit('ice candidates', {
                        candidate: candidate,
                        to: parterName,
                        sender: socket.id
                    });
                };

                pc[parterName].ontrack = (ev) => {
                    console.log(ev);
                    let str = ev.streams[0];
                    for (let i = 0; i < num; ++i)
                        if (str == mediaRecorder[i].stream)
                            return;

                    if (document.getElementById(`${num}-video`)) {
                        document.getElementById(`${num}-video`).srcObject = str;
                    } else {
                        let newDiv = document.createElement('div');
                        newDiv.id = `${num}-div`;
                        newDiv.style.width = 900;
                        newDiv.style.height = 700
                        newDiv.style.float = "left";
                        document.getElementById('videos').appendChild(newDiv);

                        let newP = document.createElement('div');
                        newP.id = `${num}-divp`;
                        newP.style.width = 900;
                        newP.innerHTML = stutable[parterName].stu_no;
                        document.getElementById(`${num}-div`).appendChild(newP);

                        let newVideo = document.createElement('video');
                        newVideo.id = `${num}-video`;
                        newVideo.autoplay = true;
                        newVideo.controls = true;
                        newVideo.srcObject = str;
                        newVideo.width = 900;
                        if (clientnum1[parterName] == undefined)
                            clientnum1[parterName] = num;
                        else
                            clientnum2[parterName] = num;
                        document.getElementById(`${num}-div`).appendChild(newVideo);
                        document.getElementById(`${num}-div`).style.display = 'none'
                        console.log(`hide ${num}-div`)
                        StartRecord(str, num);
                    }
                    num++;
                }



            }

            var socket = io();

            socket.on('connect', () => {

                console.log('connect ' + socket.id);

                // $('#user-id').text(socket.id);

                pc.push(socket.id);

                socket.emit('new user greet', {
                    sender: socket.id,
                    msg: 'hello world'
                });

                socket.on('need connect', (data) => {
                    console.log("ok we connect")
                    stutable[data.sender] = data.msg;
                    stuonline[data.msg.stu_no] = true;
                    restutable[data.msg.stu_no] = data.sender;
                    socket.emit('ok we connect', { receiver: data.sender, sender: { id: socket.id, no_id: '<%= msg.user.stu_no%>' } });
                });

                socket.on('user disconnected', (socket_id) => {
                    console.log('disconnect : ' + socket_id);
                    StopRecord(clientnum1[socket_id], "video", socket_id);
                    StopRecord(clientnum2[socket_id], "screen", socket_id);
                    stuonline[stutable[socket_id].stu_no] = false;
                })


                socket.on('sdp', (data) => {
                    if (data.description.type === 'offer') {

                        StartCall(data.sender, false);
                        let desc = new RTCSessionDescription(data.description);
                        pc[data.sender].setRemoteDescription(desc).then(() => {

                            pc[data.sender].createAnswer().then((answer) => {
                                return pc[data.sender].setLocalDescription(answer);
                            }).then(() => {
                                socket.emit('sdp', {
                                    type: 'video-answer',
                                    description: pc[data.sender].localDescription,
                                    to: data.sender,
                                    sender: socket.id
                                });

                            }).catch();//catch error function empty

                        })
                    } else if (data.description.type === 'answer') {
                        let desc = new RTCSessionDescription(data.description);
                        pc[data.sender].setRemoteDescription(desc);
                    }
                })

                socket.on('ice candidates', (data) => {
                    console.log('ice candidate: ' + data.candidate);
                    if (data.candidate) {
                        var candidate = new RTCIceCandidate(data.candidate);
                        pc[data.sender].addIceCandidate(candidate).catch();//catch err function empty
                    }
                })


            });
        }


    </script>
</body>


</html>