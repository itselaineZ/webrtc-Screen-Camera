<head>
    <title>Camera</title>
    <style>
        #user-list>li {
            font-size: 24px;
        }
    </style>
    <script type="javascript" src="/root/webrtc/fix-webm-duration.js"></script>
</head>

<body>
    <h1 id="user-id">SERVER</h1>

    <div id="videos"></div>

    <script src="//cdn.bootcdn.net/ajax/libs/socket.io/3.0.4/socket.io.js"></script>
    <script src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js"></script>
    <script type="javascript" src="/root/webrtc/fix-webm-duration.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.9.5/dist/ffmpeg.min.js"></script>
    <script src="https://www.webrtc-experiment.com/EBML.js"></script>
    <script>
	const {createFFmpeg, fetchFile} = FFmpeg;
	const ffmpeg = createFFmpeg({log:true});
        window.onload = function(){
	  //var ysFixWebmDuration = ysFixWebmDuration;
	var recorderFile;
	function getSeekableBlob(inputBlob, num) {
    // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml
    if (typeof EBML === 'undefined') {
        throw new Error('Please link: https://www.webrtc-experiment.com/EBML.js');
    }

    var reader = new EBML.Reader();
    var decoder = new EBML.Decoder();
    var tools = EBML.tools;

    var fileReader = new FileReader();
    fileReader.onload = function(e) {
        var ebmlElms = decoder.decode(this.result);
        ebmlElms.forEach(function(element) {
            reader.read(element);
        });
        reader.stop();
        var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);
        var body = this.result.slice(reader.metadataSize);
        var newBlob = new Blob([refinedMetadataBuf, body], {
            type: 'video/webm'
        });

	console.log(newBlob);
	recorderFile = newBlob;
	const url = window.URL.createObjectURL(recorderFile);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'video'+num+'.webm';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        
    };
    fileReader.readAsArrayBuffer(inputBlob);
}
	
        function getUserMedia(constrains, success, error) {
            if (navigator.mediaDevices.getUserMedia) {
                promise = navigator.mediaDevices.getUserMedia(constrains).then(success).catch(error);
            } else if (navigator.webkitGetUserMedia) {
                promise = navigator.webkitGetUserMedia(constrains).then(success).catch(error);
            } else if (navigator.mozGetUserMedia) {
                promise = navagator.mozGetUserMedia(constrains).then(success).catch(error);
            } else if (navigator.getUserMedia) {
                promise = navigator.getUserMedia(constrains).then(success).catch(error);
            }
        }

        function canGetUserMediaUse() {
            return !!(navigator.mediaDevices.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
        }

        const localVideoElm = document.getElementById("video-local");

        const iceServer = {
            iceServers: [{ urls: ["stun:ss-turn1.xirsys.com"] }, { username: "CEqIDkX5f51sbm7-pXxJVXePoMk_WB7w2J5eu0Bd00YpiONHlLHrwSb7hRMDDrqGAAAAAF_OT9V0dWR1d2Vi", credential: "446118be-38a4-11eb-9ece-0242ac140004", urls: ["turn:ss-turn1.xirsys.com:80?transport=udp", "turn:ss-turn1.xirsys.com:3478?transport=udp"] }]
        };

        //PeerConnection
        var pc = [];
        var localStream = null;
	var num = 0;
	var mediaRecorder = [];
        var recordChunks = [];
        var clientnum1 = [], clientnum2 = [];
        var recordMediaType = 'video/webm;codecs=vp8,opus';
	var startTime = [];

	function StartRecord(stream, num) {
            let option = { mimeType: recordMediaType };
            mediaRecorder[num] = new MediaRecorder(stream, option);
            console.log(num+'recorder statred');
            recordChunks[num] = [];
            mediaRecorder[num].start(80);
	    startTime[num] = new Date().getTime();

            mediaRecorder[num].ondataavailable = function (e) {
                console.log("data available", e.data);
                recordChunks[num].push(e.data);
            }

        }

        function StopRecord(num) {
            if (!mediaRecorder[num]) {
                console.log('stream '+num+' is not created!');
                return;
            }
            mediaRecorder[num].stop();
	    var duration = new Date().getTime() - startTime[num];
            console.log('recorder '+num+' stopped');

            const blob = new Blob(recordChunks[num], { type: recordMediaType });
	    getSeekableBlob(blob, num);
	    //console.log(blob);
	    //console.log(recorderFile);
        }

        function StartCall(parterName, createOffer) {

            pc[parterName] = new RTCPeerConnection(iceServer);

            pc[parterName].onicecandidate = ({ candidate }) => {
                socket.emit('ice candidates', {
                    candidate: candidate,
                    to: parterName,
                    sender: socket.id
                });
            };

            pc[parterName].ontrack = (ev) => {
		console.log(ev);
                let str = ev.streams[0];
		for (let i = 0; i<num; ++i)
		  if (str == mediaRecorder[i].stream)
			return;

                if (document.getElementById(`${num}-video`)) {
                    document.getElementById(`${num}-video`).srcObject = str;
                } else {
		    let newDiv = document.createElement('div');
		    newDiv.id=`${num}-div`;
		    newDiv.style.width=900;
		    newDiv.style.height=700
		    newDiv.style.float="left";
		    document.getElementById('videos').appendChild(newDiv);

		    let newP=document.createElement('div');
		    newP.id=`${num}-divp`;
		    newP.style.width=900;
		    newP.innerHTML=parterName;
		    document.getElementById(`${num}-div`).appendChild(newP);

                    let newVideo = document.createElement('video');
                    newVideo.id = `${num}-video`;
                    newVideo.autoplay = true;
                    newVideo.controls = true;
                    newVideo.srcObject = str;
		    newVideo.width = 900;
		    if (clientnum1[parterName] == undefined)
                        clientnum1[parterName] = num;
                    else
                        clientnum2[parterName] = num;
                    document.getElementById(`${num}-div`).appendChild(newVideo);
		    StartRecord(str, num);
		}
		num++;
            }



        }

        var socket = io();

        socket.on('connect', () => {

            console.log('connect ' + socket.id);

           // $('#user-id').text(socket.id);

            pc.push(socket.id);

            socket.emit('new user greet', {
                sender: socket.id,
                msg: 'hello world'
     	    });

            socket.on('need connect', (data) => {
                socket.emit('ok we connect', { receiver: data.sender, sender: socket.id });
            });
           
            socket.on('user disconnected', (socket_id) => {
                console.log('disconnect : ' + socket_id);
		StopRecord(clientnum1[socket_id]);
                StopRecord(clientnum2[socket_id]);
                $('#user-list li[user-id="' + socket_id + '"]').remove();
            })

           
            socket.on('sdp', (data) => {
                
                if (data.description.type === 'offer') {
                    
                    StartCall(data.sender, false);
                    let desc = new RTCSessionDescription(data.description);
                    pc[data.sender].setRemoteDescription(desc).then(() => {

                        pc[data.sender].createAnswer().then((answer) => {
                            return pc[data.sender].setLocalDescription(answer);
                        }).then(() => {
                            socket.emit('sdp', {
                                type: 'video-answer',
                                description: pc[data.sender].localDescription,
                                to: data.sender,
                                sender: socket.id
                            });

                        }).catch();//catch error function empty

                    })
                } else if (data.description.type === 'answer') {
                    let desc = new RTCSessionDescription(data.description);
                    pc[data.sender].setRemoteDescription(desc);
                }
            })

            socket.on('ice candidates', (data) => {
                console.log('ice candidate: ' + data.candidate);
                if (data.candidate) {
                    var candidate = new RTCIceCandidate(data.candidate);
                    pc[data.sender].addIceCandidate(candidate).catch();//catch err function empty
                }
            })


        });
}


    </script>
</body>


</html>
